<html>
	<head>
	</head>
	<body>
		<h1>Homework 3 Overview:</h1>
		<p>INSERT OVERVIEW HERE</p>

		<h2>Part 1: Ray Generation and Scene Intersection</h2>
		<p>In this part, we implemented the logic behind generating rays and basic pixel sampling over them, along with some basic ray intersection tests for triangles and spheres. For ray generation, given 
		some normalized coordinates x and y, we convert them to the camera space by the following transformations. CameraX = 2 * x * tan(.5 * hFovRads) - tan(.5 * hFovRads) and CameraY = 2 * y * tan(.5 * vFovRads) - tan(.5 * vFovRads).
		Where the tangent function is used to scale the image space to the camera space. With this we generate the ray vector in the camera space and then convert it to the world space using the given camera to world transformation matrix, 
		giving us our desired ray in the world space. We then implemented two intersection tests for both triangles and spheres. Triangle intersection was tested using the Moller-Trumbore algorithm, which uses barycentric coordinates 
		and cross products to determine if a ray intersects a given triangle, while also calculating the time along the ray at which the intersection occurrs. Sphere intersection was tested as given by the lecture slides, that is by 
		solving for the roots of a quadratic equation.  The following are some images that are generated from this basic implementaion of ray generation and intersection tests.</p>
		<img src="basicSpheres.png" alt="Spheres Rendered With Basic Intersection and Ray Generation">
		<img src="basicCoil.png" alt="Coil Rendered With Basic Intersection and Ray Generation">

		<h2>Part 1: Bounding Volume Hierarchy </h2>
		<p>Here we implement a BVH construction algorithm to speed up the rednering of meshes. Before this, every ray, even those that are very unlikeley to intersect with anything, are tested for intersection. 
		This results in incredibly slow rendering times for anything that is moderatley complicated. We implement a  recursive BVH construction algorithm that begins with the the largest bounding box of the object,
		and then splitting up this box into finer ones. We choose the splitting point by calculating the average centroid point of the bounding box and splitting along the x,y, or z axis. The axis is chosen by 
		calculating which split would result in the most equal amount of primitives per side of the axis. This ensures an even amount of work is done betweent nodes in the tree as well as groups closer primitives together. 
		Here are some images of some files that could only be rendered using our BVH construction algorithm.</p>
		
		<img src="dragon.png" alt="Spheres Rendered With Basic Intersection and Ray Generation">
		<img src="basicCoil.png" alt="Coil Rendered With Basic Intersection and Ray Generation">

		<p></p>
	</body>
</html>
